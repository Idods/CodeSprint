Analysis[edit]
Because the algorithm uses only simple for loops, without recursion or subroutine calls, it is straightforward to
analyze. The initialization of the Count array, and the second for loop which performs a prefix sum on the count
array, each iterate at most k + 1 times and therefore take O(k) time. The other two for loops, and the initialization
of the output array, each take O(n) time. Therefore the time for the whole algorithm is the sum of the
times for these steps, O(n + k).[1][2]

Because it uses arrays of length k + 1 and n, the total space usage of the algorithm is also O(n + k).[1]
For problem instances in which the maximum key value is significantly smaller than the number of items,
counting sort can be highly space-efficient, as the only storage it uses other than its input and output arrays
is the Count array which uses space O(k).[5]